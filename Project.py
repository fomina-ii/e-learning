#!/usr/bin/env python
# coding: utf-8

# # Проект e-learning
# **Необходимо проанализировать завершенные уроки и ответить на следующие вопросы:**
# 
# 1. Сколько студентов успешно сдали только один курс? (Успешная сдача — это зачёт по курсу на экзамене)
# 
# 2. Какой экзамен является самым сложным? Какой самым простым? Какие курсы и экзамены в рамках курса обладают самой низкой и самой высокой завершаемостью (кол-во успешных экзаменов / кол-во всех попыток сдать экзамен)?
# 
# 3. Какой средний срок сдачи экзаменов по каждому предмету?
# 
# 4. Какие самые популярные предметы (ТОП-3) по количеству регистраций на них? Предметы с самым большим оттоком (ТОП-3)?
# 
# 5. В период с начала 2013 по конец 2014 какой семестр был с самой низкой завершаемостью курсов и самыми долгими средними сроками сдачи курсов?
# 
# 6. Какая аудитория на курсе? Для определения необходимо построить адаптированные RFM-кластеры студентов.

# ### Ответы на вопросы:
# 
# **1. Сколько студентов успешно сдали только один курс?**
# 
# Ответ: 3802 студента прошли только один курс, также 536 студентов не сдали ни одного экзамена, а 295 студентов успешно прошли 2 курса
# 
# **2. Какой экзамен является самым сложным? Какой самым простым? Какие курсы и экзамены в рамках курса обладают самой низкой и самой высокой завершаемостью?**
# 
# Ответ: самым сложным и самым простым оказался один и тот же предмет, сданный в одном и том же семестре, но в разные года.
# 
# Так, сложнее всего студентам дался экзамен по предмету DDD в семестре 2013B (id 25340) - 83,72% студентов справились со сдачей экзамена. Самым простым оказался экзамен по предмету DDD в семестре 2014B (id 25361) - 92,56% студентов успешно сдали экзамен.
# 
# По имеющимся данным видно, что студенты сдавали только 6 экзаменов из 24 имеющихся. Из этих этих 6 экзаменов 4 были по одному курсу, 2 - по второму, поэтому результаты, полученные выше - не удивительны.
# 
# При этом завершаемость самих курсов (CCC и DDD) примерно одинаковая (88% и 89% соответственно).
# 
# **3. Какой средний срок сдачи экзаменов по каждому предмету?**
# 
# Ответ: по предмету CCC средний срок сдачи экзамена составляет 239 дней, по предмету DDD - 237 дней.
# 
# **4. Какие самые популярные предметы (ТОП-3) по количеству регистраций на них? Предметы с самым большим оттоком (ТОП-3)?**
# 
# Топ-3 самых популярных предмета по количеству регистраций на них: BBB - 7900 регистраций, FFF - 7751 рег., DDD - 6257 рег.
# 
# Самое большое количество отмен регистраций происходит также по этим трем предметам: FFF - 2370 отмен, BBB - 2369 отмен, DDD - 2223 отмены.
# 
# По процентному соотношению регистраций и отмен антилидером является предмет CCC - 43,89% отмен,  на втором месте DDD - 35,53% отмен, на третьей позиции FFF - 30,58% отмен.
# 
# **5. В период с начала 2013 по конец 2014 какой семестр был с самой низкой завершаемостью курсов и самыми долгими средними сроками сдачи курсов?**
# 
# Ответ: 2013B - семестр с самой низкой завершаемостью курсов; 84% студентов успешно сдали экзамен по курсу. Из 602 студентов - 504 успешно окончили курс; 98 дошли до конца курса, но не смогли сдать экзамен на оценку выше 40 баллов.
# 
# Cамые долгие средние сроки сдачи курсов наблюдались в семестре 2014J. С момента начала семестра до успешной сдачи экзаменов в среднем проходит 244 дня.
#     
# **6. Какая аудитория на курсе? Для определения необходимо построить адаптированные RFM-кластеры студентов.** 
# 
# Вывод: большинство студентов 42% (1974 чел.) лояльны к нам, они на хороший балл прошли один курс.
# 
# 39% (1821 чел.) завершили один курс с превосходным результатом.
# 
# Студенты группы "help" (11%, 536 чел.) не справились ни с одним экзаменом, возможно им нужна помощь.
# 
# Группа "job offer" (3%, 183 чел.) показала наилучшие результаты по двум курсам. Это первые претенденты на вакантные места потенциальных работодателей.
# 
# Студенты группы "Champion" (2%, 112 чел.) также продемонстрировали хорошие результаты по двум экзаменам, они будут рассматриваться во вторую очередь.
# 
# В последнюю группу вошли те, кто успешно сдал экзамен по одному курсу, но по каким-то причинам не прошел второй. С ними должна проводиться индивидуальная работа с выяснением причин провала.

# In[ ]:





# In[ ]:





# In[1]:


import pandas as pd
import numpy as np
import datetime
import matplotlib.pyplot as plt


# In[2]:


assessments         = pd.read_csv('assessments.csv')
courses             = pd.read_csv('courses.csv')
studentAssessment   = pd.read_csv('studentAssessment.csv')
studentRegistration = pd.read_csv('studentRegistration.csv')


# In[3]:


# assessments         = pd.read_csv('https://getfile.dokpub.com/yandex/get/https://disk.yandex.ru/d/PBW7aUHGuodFDA')
# courses             = pd.read_csv('https://getfile.dokpub.com/yandex/get/https://disk.yandex.ru/d/m0Z6QYNT46f9tQ')
# studentAssessment   = pd.read_csv('https://getfile.dokpub.com/yandex/get/https://disk.yandex.ru/d/lsmdbYB0iM7p3w')
# studentRegistration = pd.read_csv('https://getfile.dokpub.com/yandex/get/https://disk.yandex.ru/d/Yse4Y6RJqg_WaA')


# 1. **assessments.csv** — этот файл содержит информацию об оценках в тесте. Обычно каждый предмет в семестре включает ряд тестов с /оценками, за которыми следует заключительный экзаменационный тест (экзамен).
#  * code_module — идентификационный код предмета.
#  * code_presentation — семестр (Идентификационный код).
#  * id_assessment — тест (Идентификационный номер ассессмента).
#  * assessment_type — тип теста. Существуют три типа оценивания: оценка преподавателя (TMA), компьютерная оценка (СМА), экзамен по курсу (Exam).
#  * date — информация об окончательной дате сдачи теста. Рассчитывается как количество дней с момента начала семестра. Дата начала семестра имеет номер 0 (ноль).
#  * weight — вес теста в % в оценке за курс. Обычно экзамены рассматриваются отдельно и имеют вес 100%; сумма всех остальных оценок составляет 100%.

# In[4]:


assessments.head()


# 2. **courses.csv** — файл содержит список предметов по семестрам.
#  * code_module — предмет (идентификационный код).
#  * ode_presentation — семестр (идентификационный код).
#  * module_presentation_length — продолжительность семестра в днях.

# In[5]:


courses.head()


# 3. **studentAssessment.csv** — этот файл содержит результаты тестов студентов. Если учащийся не отправляет работу на оценку, результат не записывается в таблицу.
#  * id_assessment — тест (идентификационный номер).
#  * id_student — идентификационный номер студента.
#  * date_submitted — дата сдачи теста студентом, измеряемая как количество дней с начала семестра.
#  * is_banked — факт перезачета теста с прошлого семестра (иногда курсы перезачитывают студентам, вернувшимся из академического отпуска).
#  * score — оценка учащегося в этом тесте. Диапазон составляет от 0 до 100. Оценка ниже 40 неудачная/неуспешная сдача теста.

# In[6]:


studentAssessment.head()


# 4. **studentRegistration.csv** — этот файл содержит информацию о времени, когда студент зарегистрировался для прохождения курса в семестре.
#  * code_module — предмет (идентификационный код).
#  * code_presentation — семестр (идентификационный код)
#  * id_student — идентификационный номер студента.
#  * date_registration — дата регистрации студента. Это количество дней, измеренное от начала семестра (например, отрицательное значение -30 означает, что студент зарегистрировался на прохождение курса за 30 дней до его начала).
#  * date_unregistration — дата отмены регистрации студента с предмета. У студентов, окончивших курс, это поле остается пустым.

# In[7]:


studentRegistration.head()


# In[ ]:





# 

# >Для решения задачи проведи предварительное исследование данных и сформулируй, что должно считаться курсом. Обосновать свой выбор ты можешь с помощью фактов сдачи экзаменов, распределения студентов и уникальный идентификатор курса.*

# ### Курс - это предмет (code_module), изучаемый за определенный семестр (code_presentation)

# # 1
# >Сколько студентов успешно сдали только один курс? (Успешная сдача — это зачёт по курсу на экзамене)
# 
# *Оценка выше 40 баллов*
# 

# Нас интересует не только, какие тесты сдавали студенты, но и какие они получили результаты, поэтому объединим две таблицы studentAssessment и assessments по полю id_assessment

# In[8]:


students_results = studentAssessment.merge(assessments, on='id_assessment')
students_results


# In[9]:


# Выберем те тесты, где тип_теста == экзамен
exams = students_results.loc[students_results.assessment_type == 'Exam']
exams


# In[10]:


# добавим колонку success: если экзамен сдан успешно, то в колонку
# будет записано значение 1, иначе - 0
exams['success'] = exams.score.apply(lambda x: 1 if x >= 40 else 0)
exams


# In[11]:


# По условию нас интересует, сколько студентов успешно сдали
# только один курс, поэтому посчитаем количество сданных экзаменов
# с разбивкой по числу сданных экзаменов
exams     .groupby('id_student', as_index=False)     .agg({'success': 'sum'})     .success.value_counts()


# **Ответ: 3802 студента прошли только один курс**, также 536 студентов не сдали ни одного экзамена, а 295 студентов успешно прошли 2 курса

# In[ ]:





# In[ ]:





# # 2
# >Какой экзамен является самым сложным? Какой самым простым? Какие курсы и экзамены в рамках курса обладают самой низкой и самой высокой завершаемостью (кол-во успешных экзаменов / кол-во всех попыток сдать экзамен)?

# In[12]:


# Все попытки сдать экзамен
exam_tries = exams     .groupby('id_assessment', as_index=False)     .agg({'id_student': 'count'})     .rename(columns={'id_student': 'tries'})
exam_tries


# In[13]:


# Успешные попытки сдать экзамен
exam_success = exams     .query('success >= 1')     .groupby('id_assessment', as_index=False)     .agg({'id_student': 'count'})     .rename(columns={'id_student': 'success'})
exam_success


# In[14]:


exam_comparison = exam_tries.merge(exam_success, on='id_assessment')
exam_comparison


# In[15]:


# Посчитаем процент успешной сдачи экзаменов
exam_comparison['percentage'] = (exam_comparison.success / exam_comparison.tries * 100).round(2)
exam_comparison = exam_comparison.sort_values('percentage', ascending=False)
exam_comparison.sort_values('percentage')


# Как мы видим на таблице выше, экзамен с самым низким процентом завершаемости - это экзамен с номером 25340. Найдем его код предмета и семестра в таблице assessments

# In[16]:


assessments.query('id_assessment == 25340')


# Теперь найдем од предмета и семестра предмета с самым высоким процентом завершаемости - это экзамен с номером 25361

# In[17]:


assessments.query('id_assessment == 25361')


# Так мы выяснили, какой экзамены был легким, а какой сложным для студентов. Теперь выясним то же самое в рамках курсов.

# In[18]:


courses_comparison = exams     .groupby(['code_module', 'success'])     .agg({'id_student': 'count'})     .reset_index()     .pivot(index='code_module', columns='success', values='id_student')     .reset_index()     .rename(columns={0: 'fail', 1: 'success'})
courses_comparison['tries'] = courses_comparison['fail'] + courses_comparison['success']
courses_comparison['percentage'] = (courses_comparison['success'] / courses_comparison['tries']).round(2)
courses_comparison.sort_values('percentage')


# **Ответ:** самым сложным и самым простым оказался один и тот же предмет, сданный в одном и том же семестре, но в разные года.
# 
# Так, **сложнее всего** студентам дался экзамен по предмету DDD в семестре 2013B (id **25340**) - 83,72% студентов справились со сдачей экзамена. **Самым простым** оказался экзамен по предмету DDD в семестре 2014B (id **25361**) - 92,56% студентов успешно сдали экзамен.
# 
# По имеющимся данным видно, что студенты сдавали только 6 экзаменов из 24 имеющихся. Из этих этих 6 экзаменов 4 были по одному курсу, 2 - по второму, поэтому результаты, полученные выше - не удивительны.
# 
# При этом завершаемость самих курсов (CCC и DDD) примерно одинаковая (88% и 89% соответственно).

# In[ ]:





# In[ ]:





# # 3
# >Какой средний срок сдачи экзаменов по каждому предмету?

# Отбираем все успешные экзамены и считаем среднее по date_submitted

# In[19]:


exams.query('success == 1')     .groupby('code_module')     .agg({'date_submitted': 'mean'}).round(2)


# **Ответ: по предмету CCC средний срок сдачи экзамена составляет 239 дней, по предмету DDD - 237 дней.**

# In[ ]:





# In[ ]:





# # 4
# >Какие самые популярные предметы (ТОП-3) по количеству регистраций на них? Предметы с самым большим оттоком (ТОП-3)?
# 

# In[20]:


# Сгруппируем данные из таблицы по регистрациям по коду предмета и 
# посчитаем количество строк в группе (кол-во регистраций)
registration = studentRegistration.groupby('code_module', as_index=False)     .agg({'id_student': 'nunique'})     .sort_values('id_student', ascending=False)     .rename(columns={'id_student': 'registrations'})
registration


# In[21]:


# Удалим пустые значения из таблицы по регистрациям (те студенты, 
# которые завершили курс, именют пустые значения в колонке "дата отмены")
# Сгруппируем данные по коду предмета и посчитаем количество строк в группе (кол-во отмен)
cancellation = studentRegistration.dropna()     .groupby('code_module', as_index=False)     .agg({'id_student': 'nunique'})     .sort_values('id_student', ascending=False)     .rename(columns={'id_student': 'cancellations'})
cancellation


# In[22]:


# Создадим таблицу сравнения регистраций и отмен
comparison = registration.merge(cancellation, on='code_module')
comparison


# In[23]:


# Посчитаем процент отмен
comparison['persentage'] = (comparison.cancellations / comparison.registrations).round(2)
comparison.sort_values('persentage', ascending=False)


# In[24]:


comparison.persentage.mean()


# **Ответ:** топ-3 самых популярных предмета по **количеству регистраций** на них: BBB - 7692 регистраций, FFF - 7397 рег., DDD - 5848 рег.
# 
# Самое большое **количество отмен** регистраций происходит также по этим трем предметам: BBB - 2306 отмен, FFF - 2239 отмен, DDD - 2058 отмены.
# 
# По **процентному соотношению** регистраций и отмен антилидером является предмет CCC - 44% отмен,  на втором месте DDD - 35% отмен, на третьей позиции FFF - 30% отмен.

# In[ ]:





# In[ ]:





# # 5
# >В период с начала 2013 по конец 2014 какой семестр был с самой низкой завершаемостью курсов и самыми долгими средними сроками сдачи курсов?
# 

# In[25]:


# Посчитаем процент успешной сдачи курсов среди студентов,
# которые сдавали экзамены

semestr_comparison = exams     .groupby(['code_presentation', 'success'])     .agg({'id_student': 'nunique'})     .reset_index()     .pivot(index='code_presentation', columns='success', values='id_student')     .reset_index()     .rename(columns={0: 'fail', 1: 'success'})
semestr_comparison['tries'] = semestr_comparison['fail'] + semestr_comparison['success']
semestr_comparison['percentage'] = (semestr_comparison['success'] / semestr_comparison['tries']).round(2)
semestr_comparison.sort_values('percentage')


# In[26]:


# Посчитаем, сколько в среднем проходит дней с момента начала семестра до успешной сдачи экзаменов

exams.query('success == 1')     .groupby('code_presentation')     .agg({'date_submitted': 'mean'})     .reset_index()     .rename(columns={'date_submitted': 'average_days'}).round(2)     .sort_values('average_days', ascending=False)


# **Ответ: 2013B - семестр с самой низкой завершаемостью курсов; 84% студентов успешно сдали экзамен по курсу.** Из 602 студентов - 504 успешно окончили курс; 98 дошли до конца курса, но не смогли сдать экзамен на оценку выше 40 баллов.
# 
# **Cамые долгие средние сроки сдачи курсов наблюдались в семестре 2014J**. С момента начала семестра до успешной сдачи экзаменов в среднем проходит 244 дня.

# In[ ]:





# In[ ]:





# # 6
# >Какая аудитория на курсе? Для определения необходимо построить адаптированные RFM-кластеры студентов.
#  
# В адаптированной кластеризации используются следующие метрики:
#  * R - среднее время сдачи одного экзамена, 
#  * F - завершаемость курсов,
#  * M - среднее количество баллов, получаемое за экзамен. 
# 

# Для того, чтобы рассчитать RFM-сегменты, нам нужно сначала рассчитать оценки R, F и M по шкале от 1 (худший) до 3 (лучший).
# 
# 1. R - посчитаем среднее всемя сдачи одного экзамена.
# 2. F - посчитаем количество завершенных курсов.
# 3. M - посчитаем среднее количество баллов, полученное за экзамен в 2014 году каждым студентом.
# 4. Разделим на сегменты R, F и M.
# 5. Составим рейтинг RFM, соединив R, F и M.
# 6. Визуализируем рейтинг.

# ### R - среднее время сдачи одного экзамена

# In[27]:


rfm_r = exams.groupby('id_student')     .agg({'date_submitted': 'mean'})     .reset_index()     .rename(columns={'date_submitted': 'r_score'})
rfm_r.head()


# ### F - завершаемость курсов. 

# У нас всего 3 варианта метрики "завершаемость" для студента: не сдал ни одного курса, сдал 1, сдал 2. По сути, это сумма exam_passing для каждого студента.

# In[28]:


rfm_f = exams.groupby('id_student')     .agg({'success': 'sum'})     .rename(columns={'success': 'f_score'})     .reset_index()
rfm_f.head()


# ### M - среднее количество баллов, получаемое за экзамен

# In[29]:


rfm_m = exams.groupby('id_student')     .agg({'score': 'mean'})     .reset_index()     .rename(columns={'score': 'm_score'})
rfm_m.head()


# In[30]:


# Теперь объединим таблицы по полю id_student для дальнейшего анализа
rfm = rfm_r.merge(rfm_f, on='id_student')


# In[31]:


rfm = rfm.merge(rfm_m, on='id_student')
rfm


# In[32]:


# Посмотрим на характеристики r_score для выбора способа сортировки

rfm.r_score.describe()


# In[33]:


# Расчитаем границы интервалов для сортировки m_score
rfm.m_score.quantile(q=[0.333, 0.666, 1])


# #### # Сгруппируем данные в столбцах по средующим критериям:
# 
# * R - среднее время сдачи одного экзамена:
#     - **r_score >= 243**     
#         - AS 1  # самое долгое время сдачи
#     - **243 < r_score <= 234**
#         - AS 2  # среднее время сдачи
#     - **r_score < 234**
#         - AS 3  # самое быстрое время сдачи
#     
# * F - завершаемость курсов:
#     - **f_score == 0**
#         - AS 1  # не завершили ни один курс
#     - **f_score == 1**
#         - AS 2  # успешно завершили 1 курс
#     - **f_score == 2**
#         - AS 3  # успешно завершили 2 курса
#      
# * M - среднее количество баллов, получаемое за экзамен:
#     - **m_score < 40**
#         - AS 1  # не сдали экзамен
#     - **40  <= m_score < 70**
#         - AS 2  # сдали и получили удовлетворительный результат
#     - **m_score >= 70**
#         - AS 3  # сдали и получили отличный результат
# 
# Чем выше ранг, тем лучше

# In[34]:


def r_score(x):
    if x >= 243:
        return 1
    elif x < 234:
        return 3
    else:
        return 2

def f_score(x):
    if x == 0:
        return 1
    elif x == 1:
        return 2
    else:
        return 3

def m_score(x):
    if x < 40:
        return 1
    elif x >= 70:
        return 3
    else:
        return 2


# In[35]:


# добавим ранги в соответствующие столбцы таблицы
rfm['R'] = rfm['r_score'].apply(lambda x: r_score(x))
rfm['F'] = rfm['f_score'].apply(lambda x: f_score(x))
rfm['M'] = rfm['m_score'].apply(lambda x: m_score(x))


# In[36]:


rfm


# In[37]:


# соединим ранги в однин столбец
rfm['RFM_score'] = rfm['R'].map(str) + rfm['F'].map(str) + rfm['M'].map(str)
rfm.head()


# In[38]:


# Сгруппируем таблицу по получившимся рангам
result = rfm.groupby('RFM_score', as_index=False).agg({'id_student': 'count'})
result


# #### Аудитория разделилась на 17 категорий, опишем каждую из них, а затем разделим на смысловые подгруппы
# 
# * 111:  **help**
#     * долгое время сдачи, 
#     * не сдал ни один экзамен, 
#     * не сдал один экзамен.
# * 121: **attention**
#     * долгое время сдачи, 
#     * сдал один экзамен, 
#     * не сдал один экзамен.
# * 122: **loyal**
#     * долгое время сдачи, 
#     * сдал один экзамен, 
#     * хорошо сдал экзамен.
# * 123: **excellent**
#     * долгое время сдачи, 
#     * сдал один экзамен, 
#     * отлично сдал экзамен.
# * 132: **champion**
#     * долгое время сдачи, 
#     * сдал два экзамена, 
#     * хорошо сдал экзамен.
# * 133: **job_offer**
#     * долгое время сдачи, 
#     * сдал два экзамена, 
#     * отлично сдал экзамен.
#     
#     
# * 211: **help**
#     * не сдал ни один экзамен, 
#     * прошел один, 
#     * не сдал один экзамен.
# * 221: **attention**
#     * среднне время сдачи, 
#     * сдал один экзамен, 
#     * не сдал один экзамен.
# * 222: **loyal**
#     * среднне время сдачи, 
#     * сдал один экзамен, 
#     * хорошо сдал экзамен.
# * 223: **excellent**
#     * среднне время сдачи, 
#     * сдал один экзамен, 
#     * отлично сдал экзамен.
# * 232: **champion**
#     * среднне время сдачи, 
#     * сдал два экзамена, 
#     * хорошо сдал экзамен.
# * 233: **job_offer**
#     * среднне время сдачи, 
#     * сдал два экзамена, 
#     * отлично сдал экзамен.
# 
# 
# * 311: **help**
#     * не сдал ни один экзамен, 
#     * не прошел ни один, 
#     * не сдал один экзамен.
# * 321: **attention**
#     * быстрое время сдачи, 
#     * сдал один экзамен, 
#     * не сдал один экзамен.
# * 322: **loyal**
#     * быстрое время сдачи, 
#     * сдал один экзамен, 
#     * хорошо сдал экзамен.
# * 323: **excellent**
#     * быстрое время сдачи, 
#     * сдал один экзамен, 
#     * отлично сдал экзамен.
# * 332: **champion**
#     * быстрое время сдачи, 
#     * сдал два экзамена, 
#     * хорошо сдал экзамен.
# * 333: **job_offer**
#     * быстрое время сдачи, 
#     * сдал два экзамена, 
#     * отлично сдал экзамен.
# 
# Итак, необходимо разделить аудиторию на 6 подгрупп:
# 1. help - те, которые не смогли сдать ни один экзамен. Возможно, им нужна помощь (перевод на другой курс, продление дедлайна, дополнительные учебные материалы);
# 2. attention - те, которые успешно прошли один курс, но не сдали экзамен по второму (им нужно внимание: возможно, это отличник, но не успел сдать экзамен вовремя);
# 3. loyal - те, которые хорошо сдали один экзамена (вероятно, они лояльны к нам и могут повторно совершить покупку курса);
# 4. champion - те, которые хорошо сдали два экзамена (трудолюбивые, вероятно целеустремленные, берем их на заметку);
# 5. excellent - те, которые отлично сдали один экзамен (отличники);
# 6. job_offer - те, которые отлично сдали 2 экзамена (их можно в первую очередь рекомендовать работодателям, которые обращаются к нам за списком лучших выпускников).

# In[ ]:





# In[55]:


def rating(x):
    if x in ['111', '211', '311']:
        return 'help'
    elif x in ['121', '221', '321']:
        return 'attention'
    elif x in ['122', '222', '322']:
        return 'loyal'
    elif x in ['132', '232', '332']:
        return 'champion'
    elif x in ['123', '223', '323']:
        return 'exellent'
    else:
        return 'job_offer'


# In[56]:


rfm['Segment'] = rfm['RFM_score'].apply(lambda x: rating(x))
rfm


# In[57]:


# Визуализируем результат 
segments_counts = rfm['Segment'].value_counts().sort_values(ascending=True)

fig, ax = plt.subplots()

bars = ax.barh(range(len(segments_counts)),
              segments_counts,
              color='silver')
ax.set_frame_on(False)
ax.tick_params(left=False,
               bottom=False,
               labelbottom=False)
ax.set_yticks(range(len(segments_counts)))
ax.set_yticklabels(segments_counts.index)

for i, bar in enumerate(bars):
        value = bar.get_width()
        if segments_counts.index[i] in ['job_offer']:
            bar.set_color('firebrick')
        ax.text(value,
                bar.get_y() + bar.get_height()/2,
                '{:,} ({:}%)'.format(int(value),
                                   int(value*100/segments_counts.sum())),
                va='center',
                ha='left'
               )

plt.show()


# **Вывод:** большинство студентов 42% (1974 чел.) лояльны к нам, они на хороший балл прошли один курс.
# 
# 39% (1821 чел.) завершили один курс с превосходным результатом.
# 
# Студенты группы "help" (11%, 536 чел.) не справились ни с одним экзаменом, возможно им нужна помощь. 
# 
# Группа "job offer" (3%, 183 чел.) показала наилучшие результаты по двум курсам. Это первые претенденты на вакантные места потенциальных работодателей.
# 
# Студенты группы "Champion" (2%, 112 чел.) также продемонстрировали хорошие результаты по двум экзаменам, они будут рассматриваться во вторую очередь. 
# 
# В последнюю группу вошли те, кто успешно сдал экзамен по одному курсу, но по каким-то причинам не прошел второй. С ними должна проводиться индивидуальная работа с выяснением причин провала.

# In[ ]:




